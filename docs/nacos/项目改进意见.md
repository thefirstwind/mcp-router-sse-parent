ç»§ç»­å®Œæˆ MCP é¡¹ç›®æ¨¡å— Nacos é›†æˆå¯¹æ¯”åˆ†ææŠ¥å‘Šï¼š

## ğŸ› ï¸ **éœ€è¦å®Œå–„çš„å…³é”®åŠŸèƒ½**

### **1. ç»Ÿä¸€é…ç½®ç®¡ç†æ¡†æ¶**

#### **éœ€è¦å®ç°çš„ç»„ä»¶**:
```java
// 1. ç»Ÿä¸€é…ç½®å¸¸é‡
public class McpNacosConstant {
    public static final String SERVER_CONFIG_SUFFIX = "-mcp-server.json";
    public static final String TOOLS_CONFIG_SUFFIX = "-mcp-tools.json";
    public static final String SERVER_NAME_SUFFIX = "-mcp-service";
    public static final String SERVER_GROUP = "mcp-server";
    public static final String TOOLS_GROUP = "mcp-tools";
}

// 2. é…ç½®å±æ€§ç±»
@ConfigurationProperties(prefix = "spring.ai.alibaba.mcp.nacos")
public class NacosMcpProperties {
    private String serverAddr;
    private String username;
    private String password;
    private String namespace;
    // ... å…¶ä»–é…ç½®
}

// 3. æ³¨å†Œå±æ€§ç±»
@ConfigurationProperties(prefix = "spring.ai.alibaba.mcp.nacos.registry")
public class NacosMcpRegistryProperties {
    private String serviceNamespace;
    private String serviceGroup = "DEFAULT_GROUP";
    private boolean serviceRegister = true;
    private boolean serviceEphemeral = true;
    // ... å…¶ä»–é…ç½®
}
```

### **2. mcp-server-v2 éœ€è¦å®Œå–„çš„åŠŸèƒ½**

#### **A. å®Œæ•´çš„ Nacos æ³¨å†Œç»„ä»¶**
```java
@Component
public class EnhancedNacosRegistrationConfig {
    
    private ConfigService configService;
    private NamingService namingService;
    private McpToolsInfo toolsInfo;
    
    // 1. å·¥å…·é…ç½®å‘å¸ƒ
    private void publishToolsConfig() {
        String toolsConfigContent = JsonUtils.serialize(toolsInfo);
        configService.publishConfig(
            serverName + McpNacosConstant.TOOLS_CONFIG_SUFFIX,
            McpNacosConstant.TOOLS_GROUP,
            toolsConfigContent
        );
    }
    
    // 2. æœåŠ¡å™¨é…ç½®å‘å¸ƒ
    private void publishServerConfig() {
        McpServerInfo serverInfo = createServerInfo();
        String serverConfigContent = JsonUtils.serialize(serverInfo);
        configService.publishConfig(
            serverName + McpNacosConstant.SERVER_CONFIG_SUFFIX,
            McpNacosConstant.SERVER_GROUP,
            serverConfigContent
        );
    }
    
    // 3. åŠ¨æ€é…ç½®ç›‘å¬
    private void setupConfigListeners() {
        configService.addListener(
            serverName + McpNacosConstant.TOOLS_CONFIG_SUFFIX,
            McpNacosConstant.TOOLS_GROUP,
            new Listener() {
                @Override
                public void receiveConfigInfo(String configInfo) {
                    updateToolsConfiguration(configInfo);
                }
            }
        );
    }
    
    // 4. MD5 æ ¡éªŒå’Œå…ƒæ•°æ®ç®¡ç†
    private void registerWithMetadata() {
        Map<String, String> metadata = new HashMap<>();
        
        // é…ç½® MD5 æ ¡éªŒ
        String serverConfig = getServerConfig();
        String serverMd5 = MD5Utils.getMd5(serverConfig);
        metadata.put("server.md5", serverMd5);
        
        // å·¥å…·åç§°åˆ—è¡¨
        List<String> toolNames = extractToolNames();
        metadata.put("tools.names", String.join(",", toolNames));
        
        // ä¼ è¾“ç±»å‹
        metadata.put("transport.type", "mcp-sse");
        
        // æ³¨å†Œå®ä¾‹
        Instance instance = new Instance();
        instance.setMetadata(metadata);
        namingService.registerInstance(serviceName, group, instance);
    }
}
```

#### **B. å·¥å…·åŠ¨æ€ç®¡ç†**
```java
@Service
public class DynamicToolManager {
    
    private final Map<String, ToolMetaInfo> toolsMeta = new ConcurrentHashMap<>();
    private final ConfigService configService;
    
    // 1. å·¥å…·é…ç½®æ›´æ–°
    public void updateToolsFromNacos(String configContent) {
        try {
            McpToolsInfo toolsInfo = JsonUtils.deserialize(configContent, McpToolsInfo.class);
            
            // æ›´æ–°å·¥å…·å…ƒæ•°æ®
            if (!this.toolsMeta.equals(toolsInfo.getToolsMeta())) {
                this.toolsMeta.clear();
                this.toolsMeta.putAll(toolsInfo.getToolsMeta());
                
                // é€šçŸ¥å·¥å…·åˆ—è¡¨å˜åŒ–
                notifyToolsListChanged();
            }
            
        } catch (Exception e) {
            logger.error("Failed to update tools from Nacos", e);
        }
    }
    
    // 2. å·¥å…·æè¿°æ›´æ–°
    public void updateToolDescription(String toolName, String newDescription) {
        // æ›´æ–°æœ¬åœ°å·¥å…·æè¿°
        updateLocalToolDescription(toolName, newDescription);
        
        // å‘å¸ƒæ›´æ–°åˆ° Nacos
        publishUpdatedToolsConfig();
    }
    
    // 3. å·¥å…·å¯ç”¨/ç¦ç”¨
    public void toggleToolEnabled(String toolName, boolean enabled) {
        ToolMetaInfo meta = toolsMeta.get(toolName);
        if (meta != null) {
            meta.setEnabled(enabled);
            publishUpdatedToolsConfig();
        }
    }
}
```

### **3. mcp-router éœ€è¦å®Œå–„çš„åŠŸèƒ½**

#### **A. é…ç½®ä¸­å¿ƒé›†æˆ**
```java
@Service
public class EnhancedMcpServerService {
    
    private final ConfigService configService;
    private final NamingService namingService;
    private final Map<String, McpServerConfig> serverConfigs = new ConcurrentHashMap<>();
    
    // 1. ä»é…ç½®ä¸­å¿ƒè¯»å–æœåŠ¡å™¨é…ç½®
    public Mono<McpServerConfig> loadServerConfig(String serverName) {
        return Mono.fromCallable(() -> {
            String configContent = configService.getConfig(
                serverName + McpNacosConstant.SERVER_CONFIG_SUFFIX,
                McpNacosConstant.SERVER_GROUP,
                3000L
            );
            
            if (configContent != null) {
                return JsonUtils.deserialize(configContent, McpServerConfig.class);
            }
            return null;
        });
    }
    
    // 2. ä»é…ç½®ä¸­å¿ƒè¯»å–å·¥å…·é…ç½®
    public Mono<McpToolsInfo> loadToolsConfig(String serverName) {
        return Mono.fromCallable(() -> {
            String configContent = configService.getConfig(
                serverName + McpNacosConstant.TOOLS_CONFIG_SUFFIX,
                McpNacosConstant.TOOLS_GROUP,
                3000L
            );
            
            if (configContent != null) {
                return JsonUtils.deserialize(configContent, McpToolsInfo.class);
            }
            return null;
        });
    }
    
    // 3. é…ç½®ç¼“å­˜ç®¡ç†
    public Mono<McpServer> getServerWithConfig(String serverName) {
        return loadServerConfig(serverName)
            .zipWith(loadToolsConfig(serverName))
            .map(tuple -> {
                McpServerConfig config = tuple.getT1();
                McpToolsInfo toolsInfo = tuple.getT2();
                
                return buildMcpServerFromConfig(config, toolsInfo);
            })
            .cache(Duration.ofMinutes(5)); // ç¼“å­˜5åˆ†é’Ÿ
    }
    
    // 4. é…ç½®å˜åŒ–ç›‘å¬
    public void setupConfigListeners() {
        // ç›‘å¬æ‰€æœ‰æœåŠ¡å™¨é…ç½®å˜åŒ–
        getAllServerNames().forEach(serverName -> {
            configService.addListener(
                serverName + McpNacosConstant.SERVER_CONFIG_SUFFIX,
                McpNacosConstant.SERVER_GROUP,
                new Listener() {
                    @Override
                    public void receiveConfigInfo(String configInfo) {
                        invalidateServerCache(serverName);
                        updateServerConfig(serverName, configInfo);
                    }
                }
            );
        });
    }
}
```

#### **B. æ™ºèƒ½è´Ÿè½½å‡è¡¡**
```java
@Component
public class SmartLoadBalancer {
    
    private final Map<String, List<McpAsyncClient>> serverClients = new ConcurrentHashMap<>();
    private final Map<String, AtomicInteger> roundRobinCounters = new ConcurrentHashMap<>();
    private final Map<String, Map<String, Integer>> serverWeights = new ConcurrentHashMap<>();
    
    // 1. åŸºäºæƒé‡çš„è´Ÿè½½å‡è¡¡
    public McpAsyncClient selectClient(String serverName, String toolName) {
        List<McpAsyncClient> clients = serverClients.get(serverName);
        if (clients == null || clients.isEmpty()) {
            return null;
        }
        
        // æ ¹æ®å·¥å…·ç±»å‹é€‰æ‹©æœ€ä¼˜å®¢æˆ·ç«¯
        return selectOptimalClient(clients, toolName);
    }
    
    // 2. å¥åº·æ£€æŸ¥é›†æˆ
    public void performHealthCheck() {
        serverClients.forEach((serverName, clients) -> {
            clients.forEach(client -> {
                client.ping()
                    .timeout(Duration.ofSeconds(5))
                    .subscribe(
                        result -> updateClientHealth(serverName, client, true),
                        error -> updateClientHealth(serverName, client, false)
                    );
            });
        });
    }
    
    // 3. åŠ¨æ€æƒé‡è°ƒæ•´
    public void adjustWeights(String serverName, String clientId, int weight) {
        serverWeights.computeIfAbsent(serverName, k -> new ConcurrentHashMap<>())
                   .put(clientId, weight);
    }
}
```

### **4. mcp-client éœ€è¦å®Œå–„çš„åŠŸèƒ½**

#### **A. è´Ÿè½½å‡è¡¡å®¢æˆ·ç«¯**
```java
@Component
public class LoadBalancedMcpClient {
    
    private final NamingService namingService;
    private final ConfigService configService;
    private final Map<String, List<McpAsyncClient>> serverClients = new ConcurrentHashMap<>();
    
    // 1. æœåŠ¡å‘ç°å’Œå®¢æˆ·ç«¯ç®¡ç†
    public void initializeClients() {
        // å‘ç°æ‰€æœ‰ MCP æœåŠ¡
        List<String> serviceNames = discoverMcpServices();
        
        serviceNames.forEach(serviceName -> {
            try {
                List<Instance> instances = namingService.selectInstances(
                    serviceName, "mcp-server", true);
                
                List<McpAsyncClient> clients = instances.stream()
                    .map(this::createClientForInstance)
                    .filter(Objects::nonNull)
                    .collect(Collectors.toList());
                
                serverClients.put(serviceName, clients);
                
                // è®¢é˜…æœåŠ¡å˜åŒ–
                subscribeToServiceChanges(serviceName);
                
            } catch (Exception e) {
                logger.error("Failed to initialize clients for service: {}", serviceName, e);
            }
        });
    }
    
    // 2. æ™ºèƒ½å·¥å…·è°ƒç”¨
    public Mono<Object> callTool(String toolName, Map<String, Object> arguments) {
        return findOptimalServer(toolName)
            .flatMap(serverName -> {
                McpAsyncClient client = selectHealthyClient(serverName);
                if (client != null) {
                    return callToolWithClient(client, toolName, arguments);
                }
                return Mono.error(new RuntimeException("No healthy client available for: " + serverName));
            });
    }
    
    // 3. é…ç½®åŠ¨æ€æ›´æ–°
    public void setupConfigurationListeners() {
        // ç›‘å¬å®¢æˆ·ç«¯é…ç½®å˜åŒ–
        configService.addListener(
            "mcp-client-config.json",
            "mcp-client",
            new Listener() {
                @Override
                public void receiveConfigInfo(String configInfo) {
                    updateClientConfiguration(configInfo);
                }
            }
        );
    }
    
    // 4. æ•…éšœæ¢å¤æœºåˆ¶
    public Mono<Object> callToolWithFallback(String toolName, Map<String, Object> arguments) {
        return callTool(toolName, arguments)
            .retryWhen(Retry.backoff(3, Duration.ofSeconds(1))
                .filter(throwable -> isRetryableError(throwable)))
            .onErrorResume(throwable -> {
                logger.warn("Tool call failed, trying alternative server", throwable);
                return tryAlternativeServer(toolName, arguments);
            });
    }
}
```

#### **B. è¿æ¥æ± ç®¡ç†**
```java
@Component
public class McpConnectionPool {
    
    private final Map<String, Queue<McpAsyncClient>> connectionPools = new ConcurrentHashMap<>();
    private final Map<String, AtomicInteger> poolSizes = new ConcurrentHashMap<>();
    private final int maxPoolSize = 10;
    private final int minPoolSize = 2;
    
    // 1. è¿æ¥æ± åˆå§‹åŒ–
    public void initializePool(String serverName, List<Instance> instances) {
        Queue<McpAsyncClient> pool = new ConcurrentLinkedQueue<>();
        
        // åˆ›å»ºæœ€å°è¿æ¥æ•°
        for (int i = 0; i < minPoolSize && i < instances.size(); i++) {
            McpAsyncClient client = createClient(instances.get(i));
            if (client != null) {
                pool.offer(client);
            }
        }
        
        connectionPools.put(serverName, pool);
        poolSizes.put(serverName, new AtomicInteger(pool.size()));
    }
    
    // 2. è¿æ¥è·å–å’Œé‡Šæ”¾
    public McpAsyncClient borrowConnection(String serverName) {
        Queue<McpAsyncClient> pool = connectionPools.get(serverName);
        if (pool != null) {
            McpAsyncClient client = pool.poll();
            if (client != null) {
                poolSizes.get(serverName).decrementAndGet();
                return client;
            }
        }
        
        // å¦‚æœæ± ä¸­æ²¡æœ‰è¿æ¥ï¼Œåˆ›å»ºæ–°è¿æ¥
        return createNewConnection(serverName);
    }
    
    public void returnConnection(String serverName, McpAsyncClient client) {
        Queue<McpAsyncClient> pool = connectionPools.get(serverName);
        AtomicInteger size = poolSizes.get(serverName);
        
        if (pool != null && size.get() < maxPoolSize) {
            pool.offer(client);
            size.incrementAndGet();
        } else {
            // å¦‚æœæ± å·²æ»¡ï¼Œå…³é—­è¿æ¥
            client.close();
        }
    }
    
    // 3. è¿æ¥å¥åº·æ£€æŸ¥
    public void performHealthCheck() {
        connectionPools.forEach((serverName, pool) -> {
            pool.removeIf(client -> !isClientHealthy(client));
        });
    }
}
```

---

## ğŸ“‹ **å®æ–½ä¼˜å…ˆçº§å»ºè®®**

### **é«˜ä¼˜å…ˆçº§ (P0)**
1. **ç»Ÿä¸€é…ç½®ç®¡ç†æ¡†æ¶** - å»ºç«‹æ ‡å‡†åŒ–é…ç½®ä½“ç³»
2. **mcp-server-v2 å·¥å…·é…ç½®å‘å¸ƒ** - å®ç°å·¥å…·å…ƒæ•°æ®ç®¡ç†
3. **mcp-router é…ç½®ä¸­å¿ƒé›†æˆ** - æ”¯æŒåŠ¨æ€é…ç½®è¯»å–
4. **ä¼ è¾“ç±»å‹å…ƒæ•°æ®ä¿®å¤** - ç¡®ä¿æ­£ç¡®çš„ transport.type è®¾ç½®

### **ä¸­ä¼˜å…ˆçº§ (P1)**
1. **åŠ¨æ€é…ç½®ç›‘å¬** - å®ç°é…ç½®çƒ­æ›´æ–°
2. **è´Ÿè½½å‡è¡¡ä¼˜åŒ–** - æå‡ç³»ç»Ÿæ€§èƒ½å’Œå¯é æ€§
3. **å¥åº·æ£€æŸ¥å®Œå–„** - å¢å¼ºç³»ç»Ÿç¨³å®šæ€§
4. **è¿æ¥æ± ç®¡ç†** - ä¼˜åŒ–èµ„æºåˆ©ç”¨

### **ä½ä¼˜å…ˆçº§ (P2)**
1. **æ™ºèƒ½è·¯ç”±** - åŸºäºå·¥å…·ç±»å‹çš„è·¯ç”±ä¼˜åŒ–
2. **ç›‘æ§å’ŒæŒ‡æ ‡** - å®Œå–„ç³»ç»Ÿå¯è§‚æµ‹æ€§
3. **é…ç½®ç¼“å­˜ä¼˜åŒ–** - æå‡é…ç½®è¯»å–æ€§èƒ½
4. **æ•…éšœæ¢å¤æœºåˆ¶** - å¢å¼ºç³»ç»Ÿå®¹é”™èƒ½åŠ›

---

## ğŸ¯ **æ€»ç»“**

å½“å‰ `mcp-server-v2`ã€`mcp-router`ã€`mcp-client` é¡¹ç›®ç›¸æ¯”å‚è€ƒé¡¹ç›® `mcp-gateway-example-jdk17` åœ¨ Nacos é›†æˆæ–¹é¢å­˜åœ¨ä»¥ä¸‹ä¸»è¦å·®è·ï¼š

1. **é…ç½®ç®¡ç†ä¸ç»Ÿä¸€** - ç¼ºå°‘æ ‡å‡†åŒ–çš„é…ç½®ç®¡ç†æ¡†æ¶
2. **åŠ¨æ€é…ç½®èƒ½åŠ›ä¸è¶³** - ç¼ºå°‘é…ç½®çƒ­æ›´æ–°å’Œç›‘å¬æœºåˆ¶
3. **è´Ÿè½½å‡è¡¡ä¸å®Œå–„** - ç¼ºå°‘æ™ºèƒ½è´Ÿè½½å‡è¡¡å’Œè¿æ¥æ± ç®¡ç†
4. **å…ƒæ•°æ®ç®¡ç†ä¸å®Œæ•´** - ç¼ºå°‘å·¥å…·é…ç½®å‘å¸ƒå’ŒMD5æ ¡éªŒ
5. **æœåŠ¡å‘ç°åŠŸèƒ½ç®€å•** - ç¼ºå°‘é…ç½®ä¸­å¿ƒé›†æˆå’Œæ™ºèƒ½è·¯ç”±

é€šè¿‡å®æ–½ä¸Šè¿°å®Œå–„æ–¹æ¡ˆï¼Œå¯ä»¥æ˜¾è‘—æå‡ç³»ç»Ÿçš„å¯ç»´æŠ¤æ€§ã€å¯æ‰©å±•æ€§å’Œç¨³å®šæ€§ï¼Œä½¿å…¶è¾¾åˆ°ä¼ä¸šçº§åº”ç”¨çš„æ ‡å‡†ã€‚